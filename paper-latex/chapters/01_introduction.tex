% !TeX root = ../main.tex
% Add the above to each chapter to make compiling the PDF easier in some editors.

\chapter{Introduction}\label{chapter:introduction}

\section{Motivation}

Embedded devices have become indispensable for many people and organizations, ever more use cases being explored and solutions being deployed. Their role is increasingly more important in the day to day life, fabrics and many other environments, sometimes being key solutions and other times enabling unprecedented possibilities. Their wide application makes their security a critical point which has been continuously improved in the past. Notably, public-key cryptography is an essential cryptographic method that secures the communication inter-devices, with servers or clouds and with terminals. Public-key cryptography is commonly used in protocols that initiated communication by establishing secure channels in insecure environments. The expensive computations required by established public-key schemes such as Rivest–Shamir–Adleman (RSA)~\parencite{10.1145/359340.359342} and Elliptic Curve Cryptography (ECC)~\parencite{10.1007/3-540-39799-X_31} are, in many IoT and embedded devices, deferred to dedicated hardware accelerators that can handle large integer arithmetic efficiently. This is achieved by instruction sets and hardware-design aimed for large number computations. Beside the algorithmic efficiency of the cryptographic schemes, these processors' ability to provide efficient large computations is another key factor in securing communication. Application domains requiring real-time communication critically depend on such considerations, and speed is important in many other areas as well. It is then no wonder that much work has been put into building and optimizing such processors, cryptographic schemes and their implementations. Nowadays many of the challenges related to providing fast secure communication have been tackled and good solutions exist. In the future on the other hand, quantum computers threaten to break the established security for which so much work has been dedicated.

Cryptographic schemes such as RSA and ECC are based on various unproven assumptions from which their entire security comes from. Even if the assumptions could not be proven, these schemes have been widely accepted and deployed counting on the fact that nobody was able to break them for a long time. This changed with the emergence of Shor's algorithm~\parencite{365700} which breaks the assumptions used in the two most popular schemes. Quantum computers are momentarily not able to work with large numbers, hence our security is still in place. It is also not clear how much time it would take to construct powerful enough machines but what is sure is that if and when that happens, the world needs to be ready for it. For this reason, quantum-resistant schemes have been and are developed, tested and improved in order to come up with standards for the 'new' security. With this goal, the US National Institute of Standards and Technology (NIST), in their effort to speed up the unavoidable transition, called for and assessed new quantum-resistant schemes. They selected the key encapsulation mechanism  CRYSTALS-Kyber~\parencite{cryptoeprint:2017/634} and the digital signature schemes CRYSTALS-Dilithium~\parencite{cryptoeprint:2017/633}, FALCON~\parencite{Soni2021} and SPHINCS+~\parencite{10.1007/978-3-662-46800-5_15} as the winners. The previous cryptographic schemes used in so many applications and devices are now expected to be exchanged for one of the winning schemes. This migration is expected to take many years, though eventually, anyone that wants to stay secure will replace the old cryptography.

As important as this transition now is, it is also very challenging to adopt the new schemes. From the seven finalists, none of them require the large number arithmetic as the previous schemes did and what the in-circulation co-processors are built for. New dedicated hardware is and will continue to be developed but immediately replacing all old processors in our devices is too costly and unrealistic, therefore, the challenge of repurposing these pieces of hardware emerges. Many of the new schemes have in common the fact that they are based on ring-based lattice cryptography which requires fast multiplication of polynomials with integer coefficients. This kind of cryptography proved to lead to state-of-the-art schemes, hence researchers worked on ways of mapping polynomials to large integers and back in order to take advantage of the existent hardware capabilities. Indeed, efficient algorithms for this tasks exist and have been successfully applied to some of the secure schemes on various platforms and hardware accelerators. 

\section{Previous work}

One simple algorithm that maps polynomials from $\Z[X]$ to large integers and the other way around is Kroneker substitution~\parencite{10.1007/3-540-11607-9_1}. It claims that evaluating two polynomials at a large enough integer point and multiplying the evaluation values yields a number that corresponds to exactly one polynomial given the point of evaluation $x$. Moreover, clever modulo $x$ operations allow for recovering this polynomial. This already allows implementing the new schemes using the old co-processors but is not very efficient due to the too large resulting integer which drastically decrease the multiplication performance, as contemporary co-processors are built for integer sizes of RSA/ECC, these being considerably smaller.

Harvey's ~\parencite{HARVEY20091502} improvements to Kroneker substitution work with polynomials from the polynomial ring $\R$ and allow for decreasing the resulting integers sizes by a factor of 2 or 4 at the expense of having to perform more multiplications (by a factor of 2 respectively 4). They work by evaluating the polynomials at the roots of unity in $\Z$, namely 1 and -1. These optimizations become more advantageous the larger the integers are.~\parencite{cryptoeprint:2018/425} gives a description of using these methods for the purpose of implementing RLWE-based schemes using RSA-dedicated co-processors, and it is important to note that they re already practical, an actual implementation for a specific scheme on a specific processor being presented in~\parencite{10.1007/978-3-030-57808-4_21}.

Besides Harvey's method, there exist a couple more ways of improving Kroneker substitution by combining it with various ways of looking at the initial polynomial. Among others, the methods of Karatsuba~\parencite{karatsuba}, Toom-Cook~\parencite{Cook1969ONTM}, Schönhage-Strassen~\parencite{strassen} and Nussbaumer~\parencite{Nussbaumer1980FastPT} are the most prominent. A survey of such methods is given by Bernstein~\parencite{10.1007/978-3-030-57808-4_21}.

Recent research yielded a new approach that beats many of the old ones from multiple points of view: from number of multiplications and integer sizes to actual running speed. Kroneker+~\parencite{cryptoeprint:2020/1303} generalizes the Harvey's algorithm for polynomials in $\Rnq$ where, after Kroneker substitution which yields values in $\Zq$, more roots of unity are available.  Significant advantages show up for larger integers when comparing to Harvey's method. Kronecker+ decreases the size of integers to be multiplied and trades multiplications for more efficient additions and bit shifts by exploiting the underlying ring structure. To have a rough idea, given a trade-off parameter $t$, when the cost of $b$-bit integer multiplication is $M(b)$, the cost of the algorithm is $t \cdot M(b / t) + \mathcal{O}(t)$. Assuming that $M(b)$ is significantly smaller for smaller $b$, it makes sense to use a larger $t$ as long as the overhead factor $\mathcal{O}(t)$, which scales approximately with $t \cdot log(t)$, stays small. The ring $\Rnq$, on which Kroneker+ operates, allows for clever simplifications and efficient implementations. It's effectiveness and the fact that many important post-quantum cryptographic constructions work with polynomials in this ring, makes Kroneker+ the algorithm of choice for our goal of using the old-fashioned OTBN co-processors with the new schemes.~\autoref{tab:comparison1} from~\parencite{cryptoeprint:2020/1303} shows a comparison between different methods.

%This effectively means that that one can to work with resulting numbers of sizes smaller by any factor $t = 2^\tau$ compared to plainly applying Kroneker substitution, at the expense of having to multiply $t$ such numbers.%


\begin{table}[htpb]
  \caption[]{Table 1 from~\parencite{cryptoeprint:2020/1303}. Comparison between various polynomial multiplication methods via large integer multiplication. The parameter n is the polynomial degree, $2^l$ is the point of evaluation for Kroneker substitution, t is a parameter of the algorithms, controlling the trade-off between integer size and number of multiplications.}\label{tab:comparison1}
  \centering
  \begin{tabular}{l l l l}
    \toprule
      Algorithm & \# Muls & \# Bits\\
    \midrule
      Kroneker (KS1) & 1 & $ln + 1$ \\
      Harvey (KS2/KS3) & 2 & $ln / 2 + 1$ \\
      Harvey (KS4) & 4 & $ln / 4 + 1$ \\
      Kroneker + Karatsuba & $3^{log(t)}$ & $(ln + 1) / t$ \\
      Kroneker + Toom-Cook-t & $2t - 1$ & $ (ln + 1) / t$ \\
      Kroneker + Schön.-Strassen & $t$ & $ln / t + t + 1$ \\
      Nussbaumer + Kroneker & $2t$ & $ln/t + 1$ \\
      Kroneker+ & $t$ & $ln/t + 1$ \\
    \bottomrule
  \end{tabular}
\end{table}

\break


\section{Contribution}

The goal of this work is to inspire further implementations for other schemes and provide a basis for production-ready version so that eventually the scheme will be used by embedded devices. The Kroneker+ algorithm is implemented and fine tuned for the Dilithium digital signature scheme, on the OpenTitan Big Number Accelerator (OTBN). The winners of the NIST competition being announced, it is important to fine tune the state-of-the-art algorithms for them in order to move one step closer to wide adoption of the new schemes. The Kroneker+ can be efficiently implemented only once the parameter set is fixed, hence, by considering various aspects of the scheme, the multiplication algorithm and implementation optimizations enabled by different parameters, two sets of parameters that allows for a highly efficient implementation are chosen. Since one of the principal time consumers of the Kroneker+ method is the Number Theoretic Transform (NTT) computation, this work focuses on combining and adapting a few implementations of this transformation in order to achieve the most suitable version from both an implementation perspective as well as a running time perspective. Furthermore, a working and optimized implementation using the instruction set provided by the OTBN processor is developed and the reader is guided step by step through it. Challenges such as using a multiplier and other instructions that work on smaller bit lengths than the required integer sizes of the algorithm, manually implementing modulo reduction in an efficient way and determining the minimal required spots where it has to be applied, reducing the amount of data memory accesses by combining steps and finding workarounds when specific functionalities as register indexing are mixing show up and are addressed in this thesis. In the end an analysis including benchmarks of various steps, comparisons with other polynomial multiplication algorithms and comparisons of two different sets of parameters are is provided in order to aid in identifying further improvements of the code.
